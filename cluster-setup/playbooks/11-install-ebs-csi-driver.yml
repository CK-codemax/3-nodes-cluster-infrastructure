---
- name: Install AWS EBS CSI Driver
  hosts: master1
  become: true
  gather_facts: true
  vars_files:
    - ../vars/main.yml

  tasks:
    - name: Add aws-ebs-csi-driver Helm repository
      shell: |
        helm repo add aws-ebs-csi-driver {{ ebs_csi_driver_repository }}
        helm repo update
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: helm_repo_add
      changed_when: "'aws-ebs-csi-driver' in helm_repo_add.stdout or 'has been added' in helm_repo_add.stdout"

    - name: Get Terraform outputs
      shell: |
        cd {{ terraform_dir }} && terraform output -json
      register: terraform_outputs_json
      changed_when: false
      failed_when: false
      delegate_to: localhost

    - name: Parse Terraform outputs
      set_fact:
        terraform_outputs: "{{ terraform_outputs_json.stdout | from_json }}"

    - name: Set Terraform variables from outputs
      set_fact:
        terraform_aws_region: "{{ terraform_outputs.aws_region.value }}"
        terraform_cluster_name: "{{ terraform_outputs.cluster_name.value }}"
        terraform_env_name: "{{ terraform_outputs.environment.value }}"
        terraform_ebs_csi_driver_role_arn: "{{ terraform_outputs.ebs_csi_driver_role_arn.value }}"

    - name: Create service account for EBS CSI Driver
      shell: |
        kubectl create serviceaccount {{ ebs_csi_driver_service_account }} \
          --namespace {{ ebs_csi_driver_namespace }} \
          --dry-run=client -o yaml | kubectl apply -f -
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: sa_create
      changed_when: "'created' in sa_create.stdout or 'configured' in sa_create.stdout"

    - name: Remove IRSA annotation (not needed for self-managed clusters using instance profiles)
      shell: |
        kubectl annotate serviceaccount {{ ebs_csi_driver_service_account }} \
          eks.amazonaws.com/role-arn- \
          --namespace {{ ebs_csi_driver_namespace }} \
          --overwrite
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: sa_annotate_remove
      changed_when: sa_annotate_remove.rc == 0
      failed_when: false
      when: terraform_ebs_csi_driver_role_arn is defined and terraform_ebs_csi_driver_role_arn | length > 0

    - name: Label worker1 node for AWS workloads
      shell: |
        kubectl label node worker1 aws-workloads=enabled --overwrite
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: node_label
      changed_when: "'labeled' in node_label.stdout or 'already labeled' in node_label.stderr"
      failed_when: node_label.rc != 0 and 'already labeled' not in node_label.stderr

    - name: Install AWS EBS CSI Driver using Helm
      shell: |
        helm upgrade --install {{ ebs_csi_driver_release_name }} aws-ebs-csi-driver/{{ ebs_csi_driver_chart }} \
          --namespace {{ ebs_csi_driver_namespace }} \
          --version {{ ebs_csi_driver_chart_version }} \
          --set controller.serviceAccount.create=false \
          --set controller.serviceAccount.name={{ ebs_csi_driver_service_account }} \
          --set controller.nodeSelector.aws-workloads=enabled \
          --wait \
          --timeout {{ helm_timeout }}
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: helm_install
      changed_when: "'STATUS: deployed' in helm_install.stdout or 'has been upgraded' in helm_install.stdout"

    - name: Display Helm installation output
      debug:
        var: helm_install.stdout_lines

    - name: Verify EBS CSI Driver pods are running
      shell: |
        kubectl get pods -n {{ ebs_csi_driver_namespace }} -l app=ebs-csi-controller
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: pod_status
      until: >
        pod_status.stdout is defined and
        ('Running' in pod_status.stdout or 'Completed' in pod_status.stdout) and
        '0/2' not in pod_status.stdout and
        '0/1' not in pod_status.stdout
      retries: 30
      delay: 10
      changed_when: false

    - name: Display pod status
      debug:
        var: pod_status.stdout_lines

    - name: Verify EBS CSI Driver deployment is ready
      shell: |
        kubectl get deployment -n {{ ebs_csi_driver_namespace }} ebs-csi-controller -o jsonpath='{.status.readyReplicas}'
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: ready_replicas
      until: ready_replicas.stdout == "1" or ready_replicas.stdout == "2"
      retries: 30
      delay: 10
      changed_when: false

    - name: Display EBS CSI Driver deployment status
      shell: |
        kubectl get deployment -n {{ ebs_csi_driver_namespace }} ebs-csi-controller
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: deployment_status
      changed_when: false

    - name: Show deployment status
      debug:
        var: deployment_status.stdout_lines

    - name: Create EBS GP3 StorageClass manifest
      shell: |
        cat <<EOF | kubectl apply -f -
        apiVersion: storage.k8s.io/v1
        kind: StorageClass
        metadata:
          name: {{ ebs_csi_storage_class_name }}
          annotations:
            storageclass.kubernetes.io/is-default-class: "true"
        provisioner: ebs.csi.aws.com
        reclaimPolicy: Delete
        volumeBindingMode: WaitForFirstConsumer
        allowVolumeExpansion: true
        parameters:
          type: gp3
          fsType: ext4
        EOF
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: storageclass_create
      changed_when: "'created' in storageclass_create.stdout or 'configured' in storageclass_create.stdout"

    - name: Verify StorageClass is created
      shell: |
        kubectl get storageclass {{ ebs_csi_storage_class_name }}
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: storageclass_status
      changed_when: false
      failed_when: false

    - name: Show StorageClass status
      debug:
        var: storageclass_status.stdout_lines
      when: storageclass_status.rc == 0

    - name: Verify StorageClass is default
      shell: |
        kubectl get storageclass {{ ebs_csi_storage_class_name }} -o jsonpath='{.metadata.annotations.storageclass\.kubernetes\.io/is-default-class}'
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: default_storageclass
      changed_when: false
      failed_when: false

    - name: Display default StorageClass annotation
      debug:
        msg: "Default StorageClass annotation: {{ default_storageclass.stdout }}"
      when: default_storageclass.rc == 0

